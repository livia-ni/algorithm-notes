Binary Tree traversal

Quick Sort/ quick select
k nearest points

Merge Sort


Two pointer
Intersection of two arrays(one pointer for each array)
valid palindrome(pointers - left, right, while left < right, to see whether left character == right character)



Use array to implement hashmap function
This is very useful, to create a char array of size 128, usage: char[c] = ... to count or to set as boolean value
_409 Longest Palindrome_
_76 minimum window substring_
//one hashmap(logic is the same as two int array)
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        HashMap<Character, Integer> map = new HashMap<>();
        for(char c : t.toCharArray()){
            if(map.containsKey(c)) map.put(c, map.get(c)+1);
            else map.put(c, 1);
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(map.containsKey(s.charAt(right))){
                map.put(s.charAt(right), map.get(s.charAt(right))-1);
                if(map.get(s.charAt(right)) >= 0) count++;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    if(map.containsKey(s.charAt(left))){
                        map.put(s.charAt(left), map.get(s.charAt(left))+1);
                        if(map.get(s.charAt(left)) > 0) count--;
                    }
                    left++;
                }
            }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
//two int array
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        int[] t_map = new int[256];
        int[] s_map = new int[256];
        for(char c : t.toCharArray()){
            t_map[c]++;
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(t_map[s.charAt(right)] != 0){
                s_map[s.charAt(right)]++;
                if(t_map[s.charAt(right)] >= s_map[s.charAt(right)]) count++;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    if(t_map[s.charAt(left)] != 0){
                        s_map[s.charAt(left)]--;
                        if(s_map[s.charAt(left)] < t_map[s.charAt(left)]) count--;
                    }
                    left++;
                }
            }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
//one int array, decrease all value by 1, if not exist in string t, the value will be smaller than 0
//this value will be used to decide whether change the "count"
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        int[] map = new int[256];
        for(char c : t.toCharArray()){
            map[c]++;
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(map[s.charAt(right)] > 0){
                 count++;
            }
            map[s.charAt(right)]--;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    if(map[s.charAt(left)] == 0){
                        count--;
                    }
                    map[s.charAt(left)]++;
                    left++;
                }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
    
    
_438 Find All Anagrams in a String_
public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int[] hash = new int[128];
        for(char c : p.toCharArray()){
            hash[c]++; 
        }
        int left = 0, count = 0;
        for(int right = 0; right < s.length(); right++){
            if(hash[s.charAt(right)] > 0) count++;
            hash[s.charAt(right)]--;
            if(count == p.length()) res.add(left);
            if(right - left + 1 == p.length()){
                if(hash[s.charAt(left)] >= 0) count--;
                hash[s.charAt(left)]++;
                left++;
            }
        }
        return res;
    }
    //while loop
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> list = new ArrayList<>();
        if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;
        int[] hash = new int[256]; 
        for (char c : p.toCharArray()) {
        hash[c]++;
        }
        int left = 0, right = 0, count = p.length();
    while (right < s.length()) {
        if (hash[s.charAt(right)] >= 1) count--;
            hash[s.charAt(right)]--;
            right++;
            if (count == 0) list.add(left);
            if (right - left == p.length()){
                if(hash[s.charAt(left)] >= 0)
                   count++;
                hash[s.charAt(left)]++;
                left++;
            }
    }
    return list;
    }

Binary Search Related
_378. Kth Smallest Element in a Sorted Matrix_
(count all the elements that are <= median value, median value = left upper + right down)  

 public class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;
        while(lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int count = search_less_equal(matrix, mid);
            if(count < k) lo = mid + 1;
            else hi = mid;
        }
        return lo; //Q: why lo here can be guaranteed as a value in the matrix? 
        //A: lo/hi value will be narrowed down to a value that is in the matrix 
        //and meet the requirement that number of elements <= value equal to k
    }
    public int search_less_equal(int[][] matrix, int mid){
            int j = matrix[0].length - 1, count = 0;
            for(int i = 0; i < matrix.length; i++) {
                while(j >= 0 && matrix[i][j] > mid) j--;
                count += (j+1);
            }
        return count;
    }
}

//method using priority queue
   public class Solution {
    public class Node{
        int val, x, y;
        public Node(int val, int x, int y){
            this.val = val;
            this.x = x;
            this.y = y;
        }
    }
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>(
            new Comparator<Node>(){
               public int compare(Node a, Node b){
                return a.val - b.val;
               } 
            }
        );
        for (int j = 0; j < n; j++){
            pq.offer(new Node(matrix[0][j], 0, j));
        }
        for (int i = 0; i < k -1; i++){
            Node node = pq.poll();
            if(node.x < n - 1)
                pq.offer(new Node(matrix[node.x+1][node.y], node.x+1, node.y));
        }
        return pq.poll().val;
    }
}

_33 81 search in rotated sorted array_  (nums[mid] will be compared to nums[lo], then compare target with nums[lo] and nums[mid])

public boolean search(int[] nums, int target) {
        int lo = 0, hi = nums.length-1;
        boolean res = false;
        while(lo <= hi){
            int mid = (lo + hi) / 2;
            if(nums[mid] == target) 
            {
                res = true;
                break;
            }
            if(nums[lo] < nums[mid]){
                if(target >= nums[lo] && target < nums[mid]) hi = mid-1;
                else lo = mid+1;
            } 
            else if(nums[lo] > nums[mid]){
                if(target > nums[mid] && target <= nums[hi]) lo = mid+1;
                else hi = mid-1;
            }
            else{
                lo++;
            }
        }
        return res;
    }


_153 154 Find min in rotated sorted array_ (a[mid] should be compared to a[high], since a[low] and a[mid] could be the same element)

public int findMin(int[] nums) {
        int lo = 0, hi = nums.length-1;
        while(lo<hi){
            int mid = (lo+hi)/2;
            if(nums[mid] > nums[hi]) lo = mid+1;
            else if(nums[mid] <nums[hi]) hi = mid;
            else hi--;
        }
        return nums[lo];
    }
    

_16 3 sum closest_
_15 3 sum(need to remove duplicate ones)_

HashMap Related
_438 find anagram_
_76 minimum sliding window_
    (one hash map, two int array, one int array) one hashmap and two int array have the same logic, two int array is much faster than hash map
_140 word break II_

Java PriorityQueue Related
_378 Kth Smallest Element in a Sorted Matrix_ 
_215 kth Largest Element in an Array_

QuickSelect Related : quickselect is used to find kth smallest element
_215 kth Largest Element in an Array_ (k = nums.length - k)
_378 Kth Smallest Element in a Sorted Matrix_ (explore to see whether quick select is applicable)


TODO:
This is a list of questions that have inplace algrithom but I haven't fully understand

_4 median of two sorted array_
//Array Inplace Algorithm: 
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
         int l1 = nums1.length;
         int l2 = nums2.length;

         if(l2 > l1) return findMedianSortedArrays(nums2, nums1);
          
        //this is the index (if we merge the two array) where median number stands(when sum length is odd), when sum length is even, this is the first index of the middle two numbers
         int median = (l1+l2-1)/2; 
         int left = 0, right = l2; //right should be the length, if l2==1, right = l2-1 wont work to get the right answer
         while(left < right){
        	int mid = (left + right)/2; //cut point of l2, start point of sencond part of nums2
        	
            if(nums1[median-mid] > nums2[mid]){
        		left = mid +1;
        	}
        	else right = mid;
         }
         //when left == right, this is the point where nums2 is cut,and left is the start point of second part of nums2
        int a = Math.max((median-left >= 0)? nums1[median-left] : Integer.MIN_VALUE, (left-1 >= 0)? nums2[left-1] : Integer.MIN_VALUE);
        if(((l1+l2) & 1) == 1){
        	return (double) a;
        }

        int b = Math.min((median-left+1 < l1)? nums1[median-left+1] : Integer.MAX_VALUE, (left < l2)? nums2[left] : Integer.MAX_VALUE);
        return (double) (a+b)/2;
    }
    
_324 wiggle sort_
//use extra space method
 public void wiggleSort(int[] nums) {
        Arrays.sort(nums);
        int[] temp = new int[nums.length];
        int n = nums.length - 1;
        int mid = (nums.length+1) / 2 - 1;
        for(int i = 0; i < nums.length; i++){
            if(i%2 == 1) temp[i] = nums[n--];
            else temp[i] = nums[mid--];
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = temp[i];
        }
    }
    
    _189 rotate array_
    //in place
    public void rotate(int[] nums, int k) {
        int count = 0;
        for(int i = 0; count < nums.length; i++){
            int current = i;
            int prev = nums[i];
            do{
                int next = (current+k)%nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while(i != current);
        }
    }
    //using map to store new index
    public void rotate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put((i+k)%nums.length, nums[i]);
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = map.get(i);
        }
    }

