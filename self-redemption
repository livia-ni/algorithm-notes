questions that have specific algorithm
_31 next permutation_
public void nextPermutation(int[] nums) {
        int i = nums.length-1;
        int pre;
        //start from the end of array, find the first one which is larger than the previous one
        while(i > 0 && nums[i] <= nums[i-1]){
            i--;
        }
        //i == 0 means i reach the start of the array, just reverse the array
        // i > 0 means we find the one that is larger than its previous one, its index is i, 
        //we need to swap nums[i-1] with the first one that is larger than it starting from the end of array, which is nums[j]
        if(i > 0){
            int j = nums.length-1;
            while(j > 0 && nums[j] <= nums[i-1]){
                j--;
            }
            swap(i-1, j, nums);
        }
        reverse(i, nums.length-1, nums);
    }
    private void reverse(int lo, int hi, int[] nums){
        while(lo < hi){
            swap(lo, hi, nums);
            lo++;
            hi--;
        }
    }
    private void swap(int lo, int hi, int[] nums){
            int tmp = nums[lo];
            nums[lo] = nums[hi];
            nums[hi] = tmp;
    }

Binary Tree traversal
DFS:recursion + (need more practice on how to implement DFS)

BFS: use queue to implement a bfs

Quick select:
k nearest points

Quick sort

Merge Sort


Two pointer
Intersection of two arrays(one pointer for each array)
valid palindrome(pointers - left, right, while left < right, to see whether left character == right character)
_19 remove nth node from end of list_ (keep n gap between slow and fast)

dp related
very simple example: 
    485. max consecutive ones: use an array to store the number of consecutive ones at current index, base case res[0]=1/0;
                               update max value for each loop
    139. word break: use a boolean array to store true or false at current index of string s
         public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] f = new boolean[s.length()+1];
        f[0] = true;
        //i is the length of string s, will find a break point when "if" in the for loop is true
        for(int i = 1; i <= s.length(); i++){
            for(String str : wordDict){
                if(str.length() <= i){
                    if(f[i - str.length()] && s.substring(i-str.length(), i).equals(str)){
                        f[i] = true;
                        break;
                    }
                }
            }
        }
        for(boolean b : f){
            System.out.println(b);
        }
        return f[s.length()];
    }
    
    140. word break II
    //DFS which will cause TLE
    //it's important to know the reason that causes TLE, usually we use "memo" method to store each result from a branch
    public List<String> wordBreak(String s, List<String> wordDict) {
        List<String> res = new ArrayList<>();
        if(s.length() == 0){
            res.add("");
            return res;
        }
        for(String word : wordDict){
            if(s.startsWith(word)){
                List<String> sublist = wordBreak(s.substring(word.length()), wordDict);
                for(String subword : sublist){
                    res.add(word + (subword.isEmpty() ? "" : " ") + subword);
                }
            }
        }
        return res;
    }
    //memo DFS
    public List<String> wordBreak(String s, List<String> wordDict) {
        return helper(s, wordDict, new HashMap<String, List<String>>());
    }

    private List<String> helper(String s, List<String> wordDict, Map<String, List<String>> map) {
        if (map.containsKey(s)) {
            return map.get(s);
        }
        List<String> list = new ArrayList<>();
        if (s.length() == 0) {
            list.add("");
            return list;
        }
        for (String word : wordDict) {
            if (s.startsWith(word)) {
                List<String> tmp = helper(s.substring(word.length()), wordDict, map);
                for (String w : tmp) {
                    list.add(word + (w.isEmpty() ? "" : " ") + w);
                }
            }
        }
        map.put(s, list);
        return list;
    }

Use array to implement hashmap function
This is very useful, to create a char array of size 128, usage: char[c] = ... to count or to set as boolean value
_409 Longest Palindrome_
public int longestPalindrome(String s) {
        boolean[] chars = new boolean[128];
        int cnt = 0;
        for(char c : s.toCharArray()){
            chars[c] = !chars[c];
            //this means if(chars[c] == false)
            if(!chars[c]) cnt += 2;
        }
        if(cnt < s.length()) cnt++;
        return cnt;
    }
//using hashset
 public int longestPalindrome(String s) {
        HashSet set = new HashSet<>();
        int count = 0;
        for(int i = 0; i < s.length(); i++){
            if(set.contains(s.charAt(i))){
                set.remove(s.charAt(i));
                count++;
            }
            else{
                set.add(s.charAt(i));
            }
        }
        if(!set.isEmpty()) return count * 2 + 1;
        else return count * 2;
    }
_76 minimum window substring_
//one hashmap(logic is the same as two int array)
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        HashMap<Character, Integer> map = new HashMap<>();
        for(char c : t.toCharArray()){
            if(map.containsKey(c)) map.put(c, map.get(c)+1);
            else map.put(c, 1);
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(map.containsKey(s.charAt(right))){
                map.put(s.charAt(right), map.get(s.charAt(right))-1);
                if(map.get(s.charAt(right)) >= 0) count++;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    if(map.containsKey(s.charAt(left))){
                        map.put(s.charAt(left), map.get(s.charAt(left))+1);
                        if(map.get(s.charAt(left)) > 0) count--;
                    }
                    left++;
                }
            }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
//two int array
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        int[] t_map = new int[256];
        int[] s_map = new int[256];
        for(char c : t.toCharArray()){
            t_map[c]++;
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(t_map[s.charAt(right)] != 0){
                s_map[s.charAt(right)]++;
                if(t_map[s.charAt(right)] >= s_map[s.charAt(right)]) count++;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    if(t_map[s.charAt(left)] != 0){
                        s_map[s.charAt(left)]--;
                        if(s_map[s.charAt(left)] < t_map[s.charAt(left)]) count--;
                    }
                    left++;
                }
            }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
//one int array, decrease all value by 1, if not exist in string t, the value will be smaller than 0
//this value will be used to decide whether change the "count"
public String minWindow(String s, String t) {
        if(s == null || s.length() == 0) return "";
        int[] map = new int[256];
        for(char c : t.toCharArray()){
            map[c]++;
        }
        int left = 0, count = 0, minLen = s.length()+1, minStart = 0;
        for(int right = 0; right < s.length(); right++){
            if(map[s.charAt(right)] > 0){
                 count++;
            }
            map[s.charAt(right)]--;
                while(count == t.length()){
                    if(right-left+1 < minLen){
                        minLen = right-left+1;
                        minStart = left;
                    }
                    //when this value reaches 0, 
                    //it means this is the one that counts, before add 1 to left, we need to count--
                    if(map[s.charAt(left)] == 0){
                        count--;
                    }
                    map[s.charAt(left)]++;
                    left++;
                }
        }
        if(minLen > s.length()) return "";
        return s.substring(minStart, minStart+minLen);
    }
    
    
_438 Find All Anagrams in a String_
public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int[] hash = new int[128];
        for(char c : p.toCharArray()){
            hash[c]++; 
        }
        int left = 0, count = 0;
        for(int right = 0; right < s.length(); right++){
            if(hash[s.charAt(right)] > 0) count++;
            hash[s.charAt(right)]--;
            if(count == p.length()) res.add(left);
            if(right - left + 1 == p.length()){ // differ to 76. we move left once the right-left+1 reached p length
                if(hash[s.charAt(left)] >= 0) count--;
                hash[s.charAt(left)]++;
                left++;
            }
        }
        return res;
    }
    //while loop
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> list = new ArrayList<>();
        if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;
        int[] hash = new int[256]; 
        for (char c : p.toCharArray()) {
        hash[c]++;
        }
        int left = 0, right = 0, count = p.length();
    while (right < s.length()) {
        if (hash[s.charAt(right)] >= 1) count--;
            hash[s.charAt(right)]--;
            right++;
            if (count == 0) list.add(left);
            if (right - left == p.length()){
                if(hash[s.charAt(left)] >= 0)
                   count++;
                hash[s.charAt(left)]++;
                left++;
            }
    }
    return list;
    }
    
_49 group anagrams_
public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        Map<String, ArrayList<String>> map = new HashMap<>();
        int[] count = new int[26];
        for(String s : strs){
            char[] ch = s.toCharArray();
            Arrays.fill(count, 0);
            for(char c : ch){
                count[c - 'a']++;
            }
            StringBuilder sb = new StringBuilder("");
            for(int i : count){
                sb.append('#');
                sb.append(i);
            }
            String key = sb.toString();
            if(!map.containsKey(key)){
                map.put(key, new ArrayList<>());
            }
            map.get(key).add(s);
        }
        return new ArrayList(map.values());
    }
    
    
Binary Search Related
_378. Kth Smallest Element in a Sorted Matrix_
(count all the elements that are <= median value, median value = left upper + right down)  

 public class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;
        while(lo < hi) {
            int mid = lo + (hi - lo) / 2;
            int count = search_less_equal(matrix, mid);
            if(count < k) lo = mid + 1;
            else hi = mid;
        }
        return lo; //Q: why lo here can be guaranteed as a value in the matrix? 
        //A: lo/hi value will be narrowed down to a value that is in the matrix 
        //and meet the requirement that number of elements <= value equal to k
    }
    public int search_less_equal(int[][] matrix, int mid){
            int j = matrix[0].length - 1, count = 0;
            for(int i = 0; i < matrix.length; i++) {
                while(j >= 0 && matrix[i][j] > mid) j--;
                count += (j+1);
            }
        return count;
    }
}

//method using priority queue
   public class Solution {
    public class Node{
        int val, x, y;
        public Node(int val, int x, int y){
            this.val = val;
            this.x = x;
            this.y = y;
        }
    }
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>(
            new Comparator<Node>(){
               public int compare(Node a, Node b){
                return a.val - b.val;
               } 
            }
        );
        for (int j = 0; j < n; j++){
            pq.offer(new Node(matrix[0][j], 0, j));
        }
        for (int i = 0; i < k -1; i++){
            Node node = pq.poll();
            if(node.x < n - 1)
                pq.offer(new Node(matrix[node.x+1][node.y], node.x+1, node.y));
        }
        return pq.poll().val;
    }
}

_33 81 search in rotated sorted array_  (nums[mid] will be compared to nums[lo], then compare target with nums[lo] and nums[mid])

public boolean search(int[] nums, int target) {
        int lo = 0, hi = nums.length-1;
        boolean res = false;
        while(lo <= hi){
            int mid = (lo + hi) / 2;
            if(nums[mid] == target) 
            {
                res = true;
                break;
            }
            if(nums[lo] < nums[mid]){
                if(target >= nums[lo] && target < nums[mid]) hi = mid-1;
                else lo = mid+1;
            } 
            else if(nums[lo] > nums[mid]){
                if(target > nums[mid] && target <= nums[hi]) lo = mid+1;
                else hi = mid-1;
            }
            else{
                lo++;
            }
        }
        return res;
    }


_153 154 Find min in rotated sorted array_ (a[mid] should be compared to a[high], since a[low] and a[mid] could be the same element)

public int findMin(int[] nums) {
        int lo = 0, hi = nums.length-1;
        while(lo<hi){
            int mid = (lo+hi)/2;
            if(nums[mid] > nums[hi]) lo = mid+1;
            else if(nums[mid] <nums[hi]) hi = mid;
            else hi--;
        }
        return nums[lo];
    }
    

_16 3 sum closest_
_15 3 sum(need to remove duplicate ones)_

HashMap Related
_438 find anagram_
_76 minimum sliding window_
    (one hash map, two int array, one int array) one hashmap and two int array have the same logic, two int array is much faster than hash map
_140 word break II_

Java PriorityQueue Related
_378 Kth Smallest Element in a Sorted Matrix_ 
_215 kth Largest Element in an Array_

QuickSelect Related : quickselect is used to find kth smallest element
_215 kth Largest Element in an Array_ (k = nums.length - k)
_378 Kth Smallest Element in a Sorted Matrix_ (explore to see whether quick select is applicable)


TODO:
This is a list of questions that have inplace algrithom but I haven't fully understand

_4 median of two sorted array_
//Array Inplace Algorithm: 
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
         int l1 = nums1.length;
         int l2 = nums2.length;

         if(l2 > l1) return findMedianSortedArrays(nums2, nums1);
          
        //this is the index (if we merge the two array) where median number stands(when sum length is odd), when sum length is even, this is the first index of the middle two numbers
         int median = (l1+l2-1)/2; 
         int left = 0, right = l2; //right should be the length, if l2==1, right = l2-1 wont work to get the right answer
         while(left < right){
        	int mid = (left + right)/2; //cut point of l2, start point of sencond part of nums2
        	
            if(nums1[median-mid] > nums2[mid]){
        		left = mid +1;
        	}
        	else right = mid;
         }
         //when left == right, this is the point where nums2 is cut,and left is the start point of second part of nums2
        int a = Math.max((median-left >= 0)? nums1[median-left] : Integer.MIN_VALUE, (left-1 >= 0)? nums2[left-1] : Integer.MIN_VALUE);
        if(((l1+l2) & 1) == 1){
        	return (double) a;
        }

        int b = Math.min((median-left+1 < l1)? nums1[median-left+1] : Integer.MAX_VALUE, (left < l2)? nums2[left] : Integer.MAX_VALUE);
        return (double) (a+b)/2;
    }
    
_324 wiggle sort_
//use extra space method
 public void wiggleSort(int[] nums) {
        Arrays.sort(nums);
        int[] temp = new int[nums.length];
        int n = nums.length - 1;
        int mid = (nums.length+1) / 2 - 1;
        for(int i = 0; i < nums.length; i++){
            if(i%2 == 1) temp[i] = nums[n--];
            else temp[i] = nums[mid--];
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = temp[i];
        }
    }
    
    _189 rotate array_
    //in place
    public void rotate(int[] nums, int k) {
        int count = 0;
        for(int i = 0; count < nums.length; i++){
            int current = i;
            int prev = nums[i];
            do{
                int next = (current+k)%nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while(i != current);
        }
    }
    //using map to store new index
    public void rotate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            map.put((i+k)%nums.length, nums[i]);
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = map.get(i);
        }
    }

